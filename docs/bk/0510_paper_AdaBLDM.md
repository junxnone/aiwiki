-----

| Title     | paper AdaBLDM                                         |
| --------- | ----------------------------------------------------- |
| Created @ | `2025-04-10T07:20:03Z`                                |
| Updated @ | `2025-04-30T02:30:21Z`                                |
| Labels    | \`\`                                                  |
| Edit @    | [here](https://github.com/junxnone/aiwiki/issues/510) |

-----

# AdaBLDM

  - 论文主要介绍了一种用于生成工业缺陷样本的新算法
  - 此前方法的不足:
      - 缺陷模式单一
      - 生成区域对齐不准确
      - copy-paste 过拟合问题
  - 基于 BLDM 提出定制的混合潜在扩散模型（AdaBLDM），通过扩散模型在潜在空间生成缺陷样本，利用 “trimap”
    掩码和文本提示进行特征编辑。
  - 利用 [BLDM - Blended Latent
    Diffusion](https://arxiv.org/abs/2206.02779) 局部编辑图像的能力
  - 该模型的图像生成推理过程分为自由扩散、编辑扩散和在线解码器自适应三个阶段。
  - **trimap:** 图片背景 + 目标物体掩码 + 缺陷掩码

**此前的一些方法**

![Image](media/d8c71b4ac4d42be44dd01caba4bf7f42509cdd53.png)

## Arch

![Image](media/0e6b4e2e283b61ccc191113f7ded6937d9b9e656.png)

> \[\!NOTE\] 参考: BLDM 架构图
> ![Image](media/43464d4738a8dea37934666446db52f618430ff4.png)

![Image](media/c3ec6eb4f3a772ff3a410459872b51586f7e4079.png)

1.  **纯去噪阶段（without
    editing）**：这个阶段不进行编辑操作，主要是对输入的噪声进行单纯的去噪处理。在这个过程中，算法按照一定的规则和模型结构，对噪声数据进行处理，逐步去除噪声，为后续的编辑和图像生成奠定基础。此时模型专注于对输入数据的初步处理，以得到相对干净的潜在表示，还未涉及到对缺陷等特定特征的编辑操作。
2.  **潜在编辑阶段（latent editing
    stage）**：在这个阶段，算法开始对前一阶段得到的潜在表示进行编辑。通过使用控制三值图（trimap）和文本提示等信息，对潜在空间中的特征进行调整和修改。具体来说，会将trimap嵌入并提取特征，然后将这些特征注入到去噪解码器的相应层中，引导潜在表示朝着期望的缺陷模式进行变化，从而在潜在空间中生成具有特定缺陷特征的表示。
3.  **图像编辑阶段（image editing
    stage）**：经过潜在编辑阶段后，得到了包含所需缺陷特征的潜在表示。在图像编辑阶段，将潜在表示转换为图像形式，并进一步对图像进行编辑。这个阶段会根据潜在表示中的信息，在图像上精确地生成缺陷区域，使得生成的图像符合文本提示和trimap所指示的物体和缺陷位置及特征要求，从而得到初步的合成缺陷图像。
4.  **解码器自适应阶段（decoder adaptation
    stage）**：这个阶段主要是对解码器进行自适应调整。在前面的阶段中，虽然已经生成了包含缺陷的图像，但为了进一步提高图像的质量和准确性，需要对解码器进行微调。通过自适应调整，使得解码器能够更好地适应生成的潜在表示，从而生成更高质量的合成缺陷样本，以满足工业异常检测对样本质量的要求。

### 多阶段去噪编辑算法

![Image](media/06aa0fb549cb2ea6075e77f30194f90753bdfb77.png)

1.  **输入与初始化**：算法的输入包括无缺陷图像 $x\_{OK}$ 、三值图 $\\Gamma$ 、缺陷掩码 $M^\*\_{NG}$
    、语言提示 $y$ 、解码器 $\\Psi(·)$ 、编码器 $\\Omega(·)$ 、范围数字 $T1$ 、 $T2$ 和
    $T3$ 以及预定义的正态分布 $N(\\mu\_z, \\sigma^2\_z)$ 。

<!-- end list -->

  - 首先，通过编码器 $\\Omega$ 将无缺陷图像 $x\_{OK}$ 转换到潜在空间，得到 $z\_{OK}$ ；
  - 对缺陷掩码 $M^\**{NG}$ 进行膨胀和下采样操作得到 $M*{z\_{NG}}$ ；
  - 从预定义的正态分布 $N(\\mu\_z, \\sigma^2\_z)$ 中随机采样，得到初始的潜在向量 $z\_t$
    。同时，设置总步数 $t = T1 + T2 + T3$ 。

<!-- end list -->

2.  **自由扩散阶段（Free Diffusion Stage）**：在这个阶段，当 $t \> T2 + T3$ 时，不断对当前的潜在向量
    $z\_t$ 进行去噪操作，使用的函数是 $Denoise(zt, \\Gamma, y)$ ，这个函数可能结合了三值图
    $\\Gamma$ 和语言提示 $y$ 的信息来指导去噪过程。每次去噪后更新 $t$ ，逐步减少步数，直到 $t$ 不大于 $T2 +
    T3$ 。这一阶段主要是对初始噪声进行初步处理，为后续编辑做准备。
3.  **潜在编辑阶段（Latent Editing Stage）**：当 $t \> T3$
    时，进入潜在编辑阶段。在这个阶段，通过将当前潜在向量
    $z\_t$ 与缺陷掩码 $M\_{z\_{NG}}$ 以及 $z\_{OK}$ 进行运算（ $z\_t = z\_t \\odot
    M\_{z\_{NG}} + z\_{OK} \\odot \\neg M\_{z\_{NG}}$
    ），在潜在空间中引入缺陷信息。然后对修改后的 $z\_t$
    进行去噪操作 $Denoise(zt, \\Gamma, y)$ ，并更新 $t$
    。这个过程不断调整潜在向量，使缺陷信息在潜在空间中逐渐融入，同时通过去噪保持图像的合理性。
4.  **图像编辑阶段（Image Editing Stage）**：当 $t \\geq 0$ 时，进入图像编辑阶段。首先，使用解码器
    $\\Psi$ 将当前潜在向量 $z\_t$ 转换为图像空间的 $x\_t$ ；然后，通过编码器 $\\Omega$
    对融合了缺陷信息和原始图像信息的图像（ $x\_t \\odot M\_{NG} +
    x\_{OK} \\odot \\neg M\_{NG}$ ）进行编码，得到新的潜在向量 $z\_t$ ；接着对新的 $z\_t$
    进行去噪操作 $Denoise(zt, \\Gamma, y)$ ，并更新 $t$
    。这个阶段在图像空间和潜在空间之间不断转换和处理，进一步优化缺陷在图像中的表现。
5.  **输出**：当算法执行完所有步骤后，最终返回的 $z^\*\_{NG} = z\_0$ ，这个 $z\_0$
    就是经过多阶段去噪编辑后得到的融合了缺陷信息的潜在特征向量，可用于后续的图像生成或其他任务。这个算法通过多阶段的设计，逐步在潜在空间和图像空间中引入和优化缺陷信息，利用去噪操作保证图像质量，最终生成符合要求的带有缺陷的图像。

### Online Decoder Adaption

![Image](media/22bc51cde5d5ba536891e75a355ced36af2156df.png)

  - **输入与初始化**: 算法输入包括:
      - 融合的潜在特征 $z^\*\_{NG}$ 、
      - 无缺陷图像 $x\_{OK}$ 、
      - 最大步数 $T\_{ft}$ 、
      - 保守比率 $\\lambda\_{con}$ 、
      - 异常掩码 $M^\*\_{NG}$
      - 解码器 $\\Phi(·)$
      - 首先，使用解码器 $\\Phi$
      - 将融合的潜在特征 $z^{\\ast}*{NG}$ 转换为图像 $x^{\\ast}*{NG}$
      - 并生成反向的异常掩码 $\\overline{M}^\*\_{NG}$ 。同时，初始化步数 $t = 1$ 。
  - **循环优化阶段**：在 $t \\leq T\_{ft}$ 的循环内，算法不断对解码器进行优化。
      - 每次循环中，使用当前解码器 $\\Phi$ 对 $z^\*\_{NG}$ 进行解码，得到临时图像
        $\\widetilde{x}$ 。
      - 计算两个损失值：
          - $L\_i$ 衡量临时图像 $\\widetilde{x}$ 与无缺陷图像 $x\_{OK}$ 在非缺陷区域（由
            $\\overline{M}^**{NG}$ 标识）的差异, 公式为 $L\_i = \\sum*{i,j}
            (\\widetilde{x}(i, j) - x\_{OK}(i, j))^2 \\odot
            \\overline{M}^*\_{NG}(i, j)$
            ，通过平方差计算像素差异，并利用反向异常掩码确保只计算非缺陷区域的差异。
          - $L\_d$ 衡量临时图像 $\\widetilde{x}$ 与初始生成图像 $x^*\_{NG}$ 在缺陷区域（由
            $M^**{NG}$ 标识）的差异, 公式为 $L\_d = \\sum*{i,j}
            (\\widetilde{x}(i, j) - x^*\_{NG}(i, j))^2 \\odot
            M^*\_{NG}(i, j)$ ，同样通过平方差计算像素差异，并利用异常掩码聚焦在缺陷区域。
      - 使用AdamW优化器，结合两个损失值 $L\_i$ 和 $\\lambda\_{con}L\_d$ （其中
        $\\lambda\_{con}$ 是保守比率，用于平衡两个损失的权重）来更新解码器 $\\Phi(·)$ ，公式为
        $\\Phi(·) \\leftarrow AdamW(L\_i + \\lambda\_{con}L\_d,
        \\Phi(·))$ 。这样，解码器在优化过程中会同时考虑保持与原始无缺陷图像的相似性（通过 $L\_i$
        ）和生成符合缺陷要求的图像（通过 $L\_d$ ）。
      - 更新步数 $t = t + 1$ ，进入下一次循环，直到 $t \> T\_{ft}$ 。3.
        **输出**：循环结束后，再次使用优化后的解码器 $\\Phi$ 对
        $z^*\_{NG}$ 进行解码，得到优化后的图像 $x^**{NG}$ 并返回。这个最终的 $x^\**{NG}$
        就是经过在线解码器自适应优化后的图像，在缺陷表现和与原始图像的关联方面达到了更好的平衡。

### 前景估计算法

  - [前景估计参考方法: Target before Shooting: Accurate Anomaly Detection and
    Localization under One Millisecond via Cascade Patch
    Retrieval](https://arxiv.org/pdf/2308.06748)
  - **1 生成训练数据**
      - 利用 DenseNet201
        骨干网络处理训练图像，生成原始特征张量。将张量中的向量特征用预先定义的码本进行编码，再重新组合成码图，以此来挑选前景估计分支（FEB）的训练样本。由于大多数异常检测数据集没有明确的前景
        /
        背景标签，该算法通过特定规则生成伪标签：把图像的中心区域视为前景（正样本），周围区域视为背景（负样本），但为避免类别模糊，只选取周围区域中具有多数代码的特征作为负样本，同时舍弃中心区域具有该多数代码的样本。
  - **2 构建分类器**
      - 从所有参考图像中选取部分向量特征作为分类器的训练特征，采用 1x1
        卷积层将这些特征分为前景和背景两类。在实际应用中，对于测试图像，先预测其前景预测图，同时收集其
        K 个最近邻图像的前景预测图。通过比较测试图像和其最近邻图像的前景预测图，取对应位置的最大值，得到最终的前景估计图。

![Image](media/63f1b5ba7990ae4a88889e320c292cf38c9006f3.png)

> 由 DenseNet201 获得的深度特征和伪标签用于学习一个 1×1 卷积层。

## Reference

  - [A Novel Approach to Industrial Defect Generation through Blended
    Latent Diffusion Model with Online
    Adaptation](https://arxiv.org/abs/2402.19330)
  - [Code](https://github.com/GrandpaXun242/AdaBLDM)
  - [前景估计参考方法: Target before Shooting: Accurate Anomaly Detection and
    Localization under One Millisecond via Cascade Patch
    Retrieval](https://arxiv.org/pdf/2308.06748)
